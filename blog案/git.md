# Go で git 作ってみた

今回の記事では 2 年ほど前に Go で git を作ってみた時の記事を書こうと思います。

そもそもなぜ作ったのか？？
就活をしているときに研修室の先輩から「原田一緒に git 作らん？絶対就活で Go で git 作りましたって言ったらウケるで！」
と言われた事がきっかけです。
誰かと一緒に開発するのは面白そう、かつ、就活でウケそうと思い作ってみました。(実際就活では結構ウケました)
git を作った際にファイル構造が面白いと思いましたので記事にしてみます。

## git のファイル構造

Git は内部でファイルやコミットのハッシュ値を「オブジェクト」として.git/objects 配下に保存しています。
この git オブジェクトには以下の 4 種類があります。
ハッシュは 40 桁の 16 進数(SHA1)で、前二桁がフォルダ名にになっていて、その中に各オブジェクトが存在します。

blob オブジェクト： ファイルを zlib で圧縮したもの。ファイルシステムの「ファイル」に対応。
tree オブジェクト： Blob オブジェクトへのポインタや別の Tree オブジェクトを管理する。ファイルシステムの「ディレクトリ」に対応。
コミットオブジェクト： Tree オブジェクトを包んだもの。コミットのスナップショットに対応する Tree オブジェクトに、親コミット、コミットメッセージ、author 情報などを付加。
タグオブジェクト：特定のコミットに対して名前を付ける。主に、リリースバージョンの管理や重要なマイルストーンを示すために使用。

では、なぜこのようなファイル構造になっているのでしょうか？
このファイル構造になっていることで恩恵を受けることを二つ紹介します！

## git add(index)での差分検知

git を初めて触った時、なぜ git add をしてステージングエリアに追加しないといけないのかと思ったことはないでしょうか？(私は思いました)
それには必要な分だけ差分を検知してコミットしたいという考えがあります。

git add をするとステージングエリアに登録されるということはまず初めに習うことだと思います。
より正確にいうと.git/index に保存、更新が行われます。
保存更新処理は以下のような流れで行われます。

1. ワーキングディレクトリのスキャン
   git add コマンドが実行されると、Git は指定されたパス（ファイルやディレクトリ）をスキャンし、現在のワーキングディレクトリ(作業環境)のファイル状態を読み込みます。

2. インデックスとの比較
   ワーキングディレクトリ内のファイルの状態は、インデックスに保存されている以前の状態と比較されます。
   この比較により、以下のような変更が検出されます：

新しいファイル：ワーキングディレクトリに存在するが、インデックスには存在しないファイル。
変更されたファイル：ワーキングディレクトリとインデックスの両方に存在するが、内容が異なるファイル。
削除されたファイル：インデックスには存在するが、ワーキングディレクトリには存在しないファイル。

3. ファイルのメタデータのチェック
   Git は、ファイルの内容だけでなく、以下のメタデータもチェックします：

タイムスタンプ：ファイルが最後に変更された日時。
ファイルサイズ：ファイルのサイズ。
これにより、内容が変更されていない場合でも、ファイルが変更された可能性を早期に検出します。ただし、タイムスタンプやファイルサイズが変更されていても、内容が実際には変更されていない場合もあるため、最終的にはファイルの内容も比較されます。

4. ファイルの内容のチェック
   タイムスタンプやファイルサイズが異なる場合、Git は実際にファイルの内容を読み込み、その SHA-1 ハッシュを計算します。このハッシュ値をインデックスに保存されているハッシュ値と比較することで、内容の変更を正確に検出します。
