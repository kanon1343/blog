# Go で git 作ってみた

今回の記事では 2 年ほど前に Go で git を作ってみた時の記事を書こうと思います。

そもそもなぜ作ったのか？？
就活をしているときに研修室の先輩から「原田一緒に git 作らん？絶対就活で Go で git 作りましたって言ったらウケるで！」
と言われた事がきっかけです。
誰かと一緒に開発するのは面白そう、かつ、就活でウケそうと思い作ってみました。(実際就活では結構ウケました)
git を作った際にファイル構造が面白いと思いましたので記事にしてみます。

## git のファイル構造

Git は内部でファイルやコミットのハッシュ値を「オブジェクト」として.git/objects 配下に保存しています。
この git オブジェクトには以下の 4 種類があります。
ハッシュは 40 桁の 16 進数(SHA1)で、前二桁がフォルダ名にになっていて、その中に各オブジェクトが存在します。

blob オブジェクト： ファイルを zlib で圧縮したもの。ファイルシステムの「ファイル」に対応。
tree オブジェクト： Blob オブジェクトへのポインタや別の Tree オブジェクトを管理する。ファイルシステムの「ディレクトリ」に対応。
コミットオブジェクト： Tree オブジェクトを包んだもの。コミットのスナップショットに対応する Tree オブジェクトに、親コミット、コミットメッセージ、author 情報などを付加。
タグオブジェクト：特定のコミットに対して名前を付ける。主に、リリースバージョンの管理や重要なマイルストーンを示すために使用。

では、なぜこのようなファイル構造になっているのでしょうか？
このファイル構造になっていることで恩恵を受けることを二つ紹介します！

## git add(index)での差分検知と高速化

git を初めて触った時、なぜ git add をしてステージングエリアに追加しないといけないのかと思ったことはないでしょうか？(私は思いました)
それには必要な分だけ差分を検知してコミットしたいという考えがあります！

git add をするとステージングエリアに登録されるということはまず初めに習うことだと思います。
より正確にいうと.git/index に保存、更新が行われます。

保存更新処理は以下のような流れで行われます。

1. ワーキングディレクトリのスキャン
   git add コマンドが実行されると、Git は指定されたパス（ファイルやディレクトリ）をスキャンし、現在のワーキングディレクトリ(作業環境)のファイル状態を読み込みます。

2. インデックスとの比較
   ワーキングディレクトリ内のファイルの状態は、インデックスに保存されている以前の状態と比較されます。
   この比較により、以下のような変更が検出されます：

新しいファイル：ワーキングディレクトリに存在するが、インデックスには存在しないファイル。
削除されたファイル：インデックスには存在するが、ワーキングディレクトリには存在しないファイル。
変更された可能性があるファイル：ワーキングディレクトリとインデックスの両方に存在するファイル。

3. ファイルのメタデータのチェック
   Git は、ファイルの内容だけでなく、以下のメタデータもチェックします：

タイムスタンプ：ファイルが最後に変更された日時。
ファイルサイズ：ファイルのサイズ

これにより、内容が変更されていない場合でも、ファイルが変更された可能性を早期に検出します。ただし、タイムスタンプやファイルサイズが変更されていても、内容が実際には変更されていない場合もあるため、最終的にはファイルの内容も比較されます。

4. ファイルの内容のチェック
   タイムスタンプやファイルサイズが異なる場合、Git は実際にファイルの内容を読み込み、その SHA-1 ハッシュを計算します。このハッシュ値をインデックスに保存されているハッシュ値と比較することで、内容の変更を正確に検出します。

このように変更のないファイルを無視し、変更ファイルのあるファイルのみに圧縮処理をするため効率が上がります。
大規模なプロジェクトになると数千から数万を超えるファイルを検査する必要が出てきます。
これらを全て毎回圧縮して置き換えるとなると、すごく重たい処理になってしまいます。

## git clone、pull、reset、ブランチ切り替えでの高速化

なぜこんなに早く clone やブランチ切り替えができるのかと疑問に思ったことはないでしょうか？
その理由も git のファイル構造が影響しています。

これまで説明した通り、git はハッシュでファイルやディレクトリを管理しています。
そして、add を行う際には前コミットと比較して差分が反映されるというふうに説明しました。
その結果、git はコミット時のスナップショットを保持できます。

これが何が嬉しいのかというと、ある状態のスナップショットを持っているのでそのスナップショットに切り替えるだけでいいのです。

もし git が変更の差分を持つシステムだったらということを考えてみます。
initial commit をした状態からプロジェクトが進み、途中で参加した人が現れたとします。
その人が新しく clone をしようとすると、initial commit から次のコミットへの差分、その次の差分、、、、、と全ての差分を追わなくてはいけません。これにはコミット数に比例して時間がかかってしまいます。

その時点でのスナップショットを持っておくと、そこだけ反映すればいいので一瞬です。
よって高速に動作できるというわけです。

## よくある誤解

よく説明に git は差分で管理している、もしくはスナップショットのみで管理しているという誤解があります。
これはどちらも半分正解で、コマンドによって差分で見分ける時とスナップショットを使用する時がある、が正しいです。

add のところで紹介したようにインデックス(ステージング)に登録するときは差分、clone などはスナップショットを使用します。
特に勘違いされるのが git diff などで差分を見ていると勘違いされます。
diff は tree オブジェクトが親コミット(一つ前のコミット)の情報を持つことで比較できるというだけです。

git はこのほかにも面白いアルゴリズムを持っています。
git を知れば知るほど、git を 2 週間で作ったとされるリーナスの化け物さを感じます。
Linux を修士論文で発表して、git を二週間で作って、、、、
とんでもないですね。

以上です。
ここまで読んでくださった方、ありがとうございました。
