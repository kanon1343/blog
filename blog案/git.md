# Go で Git 作ってみた

今回は、2 年ほど前に Go で Git を作ってみた経験について書こうと思います。

## なぜ作ったのか？

就職活動中に、研修室の先輩から「原田、一緒に Git 作らん？絶対就活で『Go で Git 作りました』って言ったらウケるで！」と言われたことがきっかけです。
誰かと一緒に開発するのは面白そうだし、就活でも受けが良さそうと思い、実際に作ってみました。（実際、就活ではかなり受けました！）
Git を作る過程でファイル構造が面白いと思ったので、その点について記事にしてみます。

## Git のファイル構造

Git は内部でファイルやコミットのハッシュ値を「オブジェクト」として.git/objects 配下に保存しています。この Git オブジェクトには以下の 4 種類があります。

Blob オブジェクト：ファイルを zlib で圧縮したもの。ファイルシステムの「ファイル」に対応。
Tree オブジェクト：Blob オブジェクトや別の Tree オブジェクトを指すポインタを管理。ファイルシステムの「ディレクトリ」に対応。
コミットオブジェクト：Tree オブジェクトを包んだもので、コミットのスナップショット（瞬間的な状態のコピー）に対応。
タグオブジェクト：特定のコミットに名前を付けるためのもの。主にリリースバージョンの管理や重要なマイルストーンを示すために使用。

## なぜこのようなファイル構造になっているのか？

このファイル構造の利点について、2 つの例を紹介します。

## git add (インデックス) による差分検知と高速化

初めて Git を触った時、なぜ git add でステージングエリアに追加しないといけないのか疑問に思ったことはないでしょうか？（私は思いました）
これは、必要な分だけ差分を検知してコミットしたいという考えに基づいています。

git add を実行すると、指定されたファイルやディレクトリがステージングエリアに登録されます。
より正確には、.git/index に保存、更新されます。

保存・更新の流れは以下の通りです。

1. ワーキングディレクトリのスキャン
   git add コマンドが実行されると、Git は指定されたパスのファイル状態を読み込みます。

2. インデックスとの比較
   ワーキングディレクトリ内のファイル状態は、インデックスに保存されている以前の状態と比較され、以下のような変更が検出されます。

新しいファイル：ワーキングディレクトリに存在するが、インデックスには存在しないファイル。
削除されたファイル：インデックスには存在するが、ワーキングディレクトリには存在しないファイル。
変更された可能性があるファイル：ワーキングディレクトリとインデックスの両方に存在するファイル。

3. ファイルのメタデータのチェック：Git はファイルの内容だけでなく、以下のメタデータもチェックします。

タイムスタンプ：ファイルが最後に変更された日時。
ファイルサイズ：ファイルのサイズ。
これにより、内容が変更されていない場合でも、ファイルが変更された可能性を早期に検出します。
ただし、タイムスタンプやファイルサイズが変更されていても、内容が実際には変更されていない場合もあるため、最終的にはファイルの内容も比較されます。

4. ファイルの内容のチェック
   タイムスタンプやファイルサイズが異なる場合、Git は実際にファイルの内容を読み込み、その SHA-1 ハッシュを計算します。
   このハッシュ値をインデックスに保存されているハッシュ値と比較することで、内容の変更を正確に検出します。

これにより、変更のないファイルを無視し、変更のあるファイルのみに圧縮処理を行うため、効率が向上します。
大規模なプロジェクトでは、数千から数万を超えるファイルを検査する必要が出てきます。
これらを全て毎回圧縮して置き換えると、非常に重たい処理になってしまいます。

## git pull, reset, ブランチ切り替えでの高速化

なぜこれらの操作がこんなに早いのか疑問に思ったことはないでしょうか？
その理由もは Git のファイル構造を利用したスナップショットの作成にあります。

Git はハッシュと圧縮データでファイルやディレクトリを管理し、git add の際には前コミットと比較して差分を反映します。
その結果、Git はコミット時のスナップショット(瞬間的な状態のコピー)を保持できます。
スナップショットを持っていることで、そのスナップショットに切り替えるだけでいいのです。

もし Git が変更の差分を持つシステムだった場合、初期コミットから最新コミットまでのすべての差分を追跡しなければなりません。
これには各コミットの差分を適用する時間が必要であり、コミット数が増えるほど時間がかかってしまいます。

スナップショットを作成することで、Git は特定の時点の完全な状態を持つことができます。
これにより、その状態に一瞬で切り替えることができるため、ブランチ切り替えやリセットが非常に高速に行えます。
Git のファイル構造がこのように設計されているため、大規模なプロジェクトでも迅速な操作を可能にしています。

Git はこのほかにも面白いアルゴリズムを持っています。
Git を知れば知るほど、Git を 2 週間で作ったとされるリーナス・トーバルズの凄さを感じます。
Linux を修士論文で発表し、Git を二週間で作り上げるとは、とんでもないですね。

以上です。ここまで読んでくださった方、ありがとうございました
